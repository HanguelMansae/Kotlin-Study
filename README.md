# Kotlin-Study
## 1. 목표

 ### 1. 안드로이드 앱 개발을 위한 Kotlin을 공부
###  2. 내가 알고 있는 것을 정리
###  3. 기억에 도움이 되기 위해
###  4. 프로젝트에 기여


## 2. 정리

### 2.1 컴포넌트란
컴포넌트란 어플리케이션을 구성하는 하나의 단위. => 여러개의 컴포넌트로 어플리케이션이 구성됨.
안드로이드에서는 클래스를 이용하여 컴포넌트를 구성
> #### ★★★ 하지만 앱 내의 모든 클래스가 컴포넌트인 건 X
> >모든 컴포넌트는 클래스 로 만들어짐, But 모든 클래스가 컴포넌트인건 X
그래서 앱은 크게 컴포넌트 클래스, 일반 클래스로 나뉘어짐.
####         2.1.1 컴포넌트 클래스, 일반 클래스 구분 방법 
생명주기의 관리 주체가 개발자 코드면 일반 클래스 , 안드로이드 시스템 이면 컴포넌트 클래스
####         2.1.1 컴포넌트 클래스 종류
##### 1. 액티비티 컴포넌트 : 화면 구성하는 컴포넌트, 액티비티에서 출력된 내용이 화면으로 반영
##### 2. 서비스 컴포넌트 : 백그라운드 작업 컴포넌트, 화면으로 출력되지 않음, 백그라운드에서 장기간 실행할 업무 처리
##### 3. 컨텐츠 프로바이더 : 앱 데이터 공유 컴포넌트, 앱 간에 데이터를 공유할 수도 있는데 그 때 다른 앱이 나의 앱의 데이터에 접근하고자 한다면 내 앱의 컨텐츠 프로바이더를 통해 접근함
##### 4. 브로드캐스트 리시버 컴포넌트 : 시스템 이벤트 발생시 실행되는 컴포넌트 ex : 부팅 완료, 배터리 방전 등
> ★★★ 이것들은 모드 안드로이드 시스템에서 생명주기를 관리하지만 만드는 것 자체는 개발자가 직접 만들어야 함  => 생명주기 관리 주체랑은 상관없이 당연히 모든 코드는 개발자가 만들어야 함.

### 2.2 어플리케이션 라이브러리
어플리케이션 라이브러리란 다른 어플리케이션을 앱 내에서 라이브러리처럼 사용하는 것을 의미
>ex : 카카오톡 내에서 촬영하기(카메라 앱) 사용
### 2.3 리소스
리소스란 코드에서 변하지 않는 정적인 값, 이를 코드에 담지 않고 분할해서 개발 생산성, 유지 보수성을 높임
> ex : 어떤 문자열 내용을 담은 값이 있다면 여기에 name을 붙여서 필요할 때 바로 접근해서 사용
### 2.4 프로젝트 파일
#### 2.4.1 Gradle 파일
Gradle 파일은 앱 빌드하기 위한 설정이 있는 파일
라이브러리 버전 , 플러그인, min, max SDK등을 설정할 수 있음
#### 2.4.2 AndroidMenifest.xml
이하 메인 환경 파일이라고 부름. 앱 내에서 어플의 이름, 아이콘 등을 설정할 수 있음
★XML 파일을 보면 값으로 @~꼴의 값을 주는 것을 볼 수 있는데 이때 @는 리소스를 의미
> ex : @string/app_name 은 res/values/strings.xml 파일에 app_name으로 등록된 리소스를 의미

★ 컴포넌트 클래스는 시스템에서 생명주기를 관리하므로 액티비티, 서비스, 브로드캐스트 리시버, 컨텐츠 프로바이더는 모두 메니페스트의 각각의 태그 안에 모두 등록되어 있어야 함
> 즉 모든 액티비티 파일은 매니페스트 파일내에 등록해서 관리하지 않으면 만들어도 무쓸모

#### 2.4.3 리소스 폴더
####  2.4.3.1 종류
1. drawable : 이미지 리소스
2. layout : UI 구성에 필요한 XML 리소스
3.  mipmap : 앱 아이콘 이미지
4.  values : 문자열 등의 값으로 사용할 리소스

여기에 파일을 넣으면 코드에서 R.~로 이용할 수 있음
> drawable 파일에 person1.png를 넣었다면 R.drawable.png로 호출해서 꺼낼 수 있음

★리소스 파일은 알파벳 대문자를 이용할 수 없음 -> _를 써서 만드는 것이 일반적
#### 2.4.3 레이아웃 XML 파일
**★AppCompatActivity()는 Activity의 하위 클래스로 액티비티를 만들고 싶다면 만들 클래스에 저것을 상속받아야 함
★액티비티 클래스가 호출되면 onCreate()라는 함수가 자동으로 실행되고, 내부 구문을 실행
★setContentView()는 레이아웃을 인자로 받아 해당 레이아웃을 화면으로 출력하는 함수.**

### 2.5 코틀린
#### 2.4.1 패키지와 임포트
기본적으로 코틀린 파일(.kt)를 만들면 최상단에 package ~가 있는데 이는 컴파일할 때 만들어지는 클래스 파일의 위치를 알려준다. 
★만약 내부 파일에는 없지만 **다른 파일에 있는 것을 쓰고 싶을 때 package 경로가 동일하다면 별 다른 선언 없이 바로 접근해 사용이 가능**하지만 **다르다면 쓰고자 하는 것을 import 해주어야만 사용할 수 있음** 
#### 2.4.2 val과 var
var은 variable의 약자로 유동적으로 초기 값이 할당된 이후에도 값을 바꿀 수 있는 변수를 의미
val은 value의 약자로 한번 초기 값이 할당되면 변경할 수 없는 변수 선언 시 사용
#### 2.4.3 변수 명시
변수를 선언할 때 변수 이름 뒤에 :자료형 꼴로 자료형을 명시할 수 있음
> var name: string = "name"
하지만 자동 타입 추론도 되기 때문에 꼭 할 필요는 X, 다만 명확하게 하기 위해 나쁠 것도 X
#### 2.4.4 초기 값
기본적으로 함수의 영역에서 벗어난 변수(소위 전역변수)나 클래스 내부의 변수인 경우에는 무조건 선언 시에 초기 값을 할당해야만 함
하지만 함수 내부의 경우 바로 초기 값을 할당할 필요는 X
**Late Init, lazy**
다만 **불가피하게 선언이 늦어질 때**가 있음
이를 위해 필요한게 **Late Init, lazy** 키워드
##### Late Init : 초기값을 바로 할당하지 않아도 되지만 1. var만 사용 가능 2. int , double등 적용 불가능한 자료 값이 존재
##### lazy : 변수 선언문 뒤에 by lazy{코드 내용} 꼴로 사용함 변수 최초 사용 시 1회만 코드 내용이 실행되며, 여러줄이 있을 경우 가장 마지막 값이 해당 변수의 값으로 할당됨.
#### 2.4.5 데이터 타입
코틀린도 자바처럼 데이터 타입이 **모두 클래스**
#### 2.4.5.1 문자열 템플릿
**★string 값에 어떤 다른 데이터 타입 값을 포함하고자 할 때 ${변수}로 해당 변수의 값을 string 내에 넣어줄 수 있음**
#### 2.4.5.2 Any, Unit, Nothing
1. **Any**는 **최상위 클래스**로 모든 클래스는 Any의 하위 클래스이다. => Any로 선언한 변수는 **어떤 값이든 할당할 수 있음**
2. **Unit**은 주로 함수에서 **return 값이 없다는 것을 명시적으로 표현**하기 위해 사용, 함수 선언 시 return 값 생략 시 자동 적용
	> fun 함수(): Unit{ 코드내용} 꼴
3. **Nothing** Nothing으로 선언한 변수는 null만 대입 가능 => **변수로 사용하기보다 항상 null만 반환하는 함수 등을 위해 사용**
#### 2.4.5.2 Null 허용
모든 변수는 null 값을 대입할 수 있음. 그러나 변수를 사용할 때 해당 **변수의 null 사용 유무 구분 위해 ?로 구분**
**타입 명시 뒤에 ?를 사용하지 않으면 null 값 할당 비허용
?를 사용하면 null 값 할당 허용**
**?를 사용한 변수는 사용할 때에도 ?를 뒤에 붙여서 사용해야 함**
**!!는 변수를 사용할 때 변수 값이 null이면 예외를 발생시키는 연산자 => 변수!!로 사용**
#### 2.4.5.3 함수
**함수의 매개변수는 기본값을 선언할 수 있음** => 기본값이 있다면 굳이 인자를 호출 시 전달하지 않아도 기본 값으로 적용
인자 전달 시 **인자: 자료형 = 기본값** 꼴로 선언
<pre><code>
fun some(data1: Int, data2: Int = 10): Int{ // data2인자에 기본값 10 적용
	return data1	
}
</code></pre>
**또한 매개변수명을 지정하면 호출 시 변수 값 순서 바꾸기 가능**
호출할 때 **함수(매개변수이름 = 값)** 꼴로 호출
#### 2.4.5.4 컬렉션
코틀린에는 Array, List, Set, Map의 컬렉션이 존재
**기본적으로 초기화 시 (var/val) 이름 = 컬렉션Of<자료형>(초기화할 값들)**이지만
Array와 달리 List, Set, Map은 가변적으로도 사용할 수 있는 것들이라 만약 가변적으로 사용하고 싶다면 앞에 Mutable을 붙혀서 **(var/val) 이름 = Mutable컬렉션Of<자료형>(초기화할 값들)**과 같은 꼴로 선언해서 사용

#### 조건문 when
**when(data){ 조건 -> {코드 내용}, ~}** 꼴로 사용하며 data안에 있는 값이 **{}내의 조건과 일치하는 것의 코드를 실행함 c++의 switch와 유사한 것 같음 꼭 값이 data일 필요는 없고 조건이 데이터 타입 등이 될 수도 있음**
**★is 자료형은 타입을 확인할 수 있음**
**★when은 내부에 else문이 생략 불가능**
### 2.4.6 클래스
#### 2.4.6.1 상속과 오버라이드
**클래스는 다른 클래스에게 상속을 할 수 있고 이를 허용하기 위해서 class 키워드 앞에 open 키워드를 사용함. 그리고 내부의 함수의 override를  허용하고 싶다면 함수 맨 앞에 open이란 키워드를 사용함.** 또한 상속하고자 하는 클래스는 class 이름:상속받을 클래스 이름{ 코드내용 } 꼴로 상속받을 수 있음
그리고 **상속받은 클래스 내의 함수, 변수들을 수정할 수도 있는데 이때 맨 앞에 override라는 키워드를 꼭 명시해주어야 함**
<pre><code>
open class S{
	open fun A(){~}
}
class B: S(){
	override fun A(){~~}
}
</code></pre>

